<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" creationComplete="init()">
	<mx:Script>
		<![CDATA[
			import com.adobe.images.JPGEncoder;
			import com.netease.core.algorithm.CNavMesh;
			import com.netease.core.algorithm.astar.NavMeshAStar;
			import com.netease.core.algorithm.astar.NavmeshAstarNode;
			import com.netease.core.geom.CTriangle;
			
			import flash.utils.getTimer;
			
			import mx.controls.List;
			private var MODE_NORMAL:int = 0;
			private var MODE_EDIT_WALL:int = 1;
			private var MODE_EDIT_ROAD:int = 2;
			private var MODE_FIND_PATH:int = 3;
			private var TERRAIN_ROAD:int = 0;
			private var TERRAIN_WALL:int = 1;
			[Bindable]
			private var _bmp:Bitmap=null;
			private var _recordList:Array=[];
			[Bindable]
			private var _zoom:int = 100;
			[Bindable]
			private var _editMode:int;
			private var editWidth:int = 800;
			private var editHeight:int = 500;
			private var arcs:Array;
			private var arcsGrid:Array;
			private var gridBitmapData:BitmapData;
			private var _gridBitmap:Bitmap;
			private var rowNum:int;
			private var colNum:int;
			[Bindable]
			private var _editTerrainSize:int=1;
			
			private var astarNodeList:Vector.<NavmeshAstarNode>;
			private var findPathStep:int = 0;
			private var findPathSX:int;
			private var findPathSY:int;
			private var findPathEX:int;
			private var findPathEY:int;
			private var path:Array;
			private function init():void{
				_bmp = new Bitmap();
				uiBitmap.addChild(_bmp);
				_gridBitmap = new Bitmap();
				uiTerrain.addChild(_gridBitmap);
				refreshBitMapData();
			}
			override public function set visible(value:Boolean):void{
				super.visible = value;
				refreshBitMapData();
			}
			public function refreshBitMapData():void{
				var i:int,j:int;
				if(_bmp&&_bmp.bitmapData != Data.bitmapData){
					_bmp.bitmapData = Data.bitmapData;
					_recordList = [];
					uiTerrainGrid.graphics.clear();
					if(_bmp.bitmapData){
						uiTerrainGrid.graphics.lineStyle(2,0xcccccc);
						var bmpWidth:int = _bmp.bitmapData.width;
						var bmpHeight:int = _bmp.bitmapData.height;
						rowNum = Math.ceil(bmpWidth/Config.terrainWidth);
						colNum = Math.ceil(bmpHeight/Config.terrainHeight);
						for(i=0; i<=bmpWidth; i+=Config.terrainWidth){
							uiTerrainGrid.graphics.moveTo(i-1,0);
							uiTerrainGrid.graphics.lineTo(i-1,bmpHeight);
						}
						for(j=0; j<=bmpHeight; j+=Config.terrainHeight){
							uiTerrainGrid.graphics.moveTo(0,j-1);
							uiTerrainGrid.graphics.lineTo(bmpWidth,j-1);
						}
						
						gridBitmapData = _bmp.bitmapData.clone();
						gridBitmapData.fillRect(new Rectangle(0,0,gridBitmapData.width,gridBitmapData.height),0xffffff);
						_gridBitmap.bitmapData = gridBitmapData;
						clearTerrainInfo();
						
					}
				}
			}
			private function onBitmapDataLoadComplete(client:Object,data:Object):void{
				
			}
			private function undoClick():void{
				var _record:Object = _recordList.pop();
			}
			private function saveTerrianInfoClick():void{
				var mapId : int = 0;
				var mapWidth : int = _bmp.width;
				var mapHeight : int = _bmp.height;
				var stepX : int = Config.terrainWidth;
				var stepY : int = Config.terrainHeight;
				var bytes:ByteArray = new ByteArray();
				var index:int = 0;
				for( var i:int=0; i < rowNum; i++)
				{
					for( var j:int=0; j<colNum; j++)
					{
						var byteIndex:int = index/8;
						var bitIndex:int = index%8;
						var isWall:Boolean = arcs[i][j]==1?true:false;
						var ori:uint = bytes[byteIndex];
						if( isWall ) {
							bytes[byteIndex] = bytes[byteIndex] | (1 << bitIndex);
						}
						index++;
					}
				}
				bytes.compress();
				var file:File = new File( Data.file.nativePath + Config.wallName);
				var stream:FileStream = new FileStream();
				var data:ByteArray = new ByteArray();
				data.writeBytes( bytes );
				data.compress();
				stream.open(file, FileMode.WRITE);
				stream.writeBytes(data)
				stream.close();
			}
			private function loadTerrainInfoClick():void{
				var file:File = new File(Data.file.nativePath + Config.wallName);
				var stream:FileStream = new FileStream();
				var data:ByteArray = new ByteArray;
				stream.open(file, FileMode.READ);
				stream.readBytes(data, 0, stream.bytesAvailable);
				data.uncompress();
				var bytes : ByteArray = new ByteArray();
				data.readBytes(bytes,0,stream.bytesAvailable);
				bytes.uncompress();
				var index:int = 0;
				for(var i:int=0; i<rowNum; i++){
					for(var j:int=0; j<colNum; j++){
						var byteIndex:int = index / 8;
						var bitIndex:int = index % 8;
						var byte:uint = bytes[byteIndex];
						setTerrainInfo(i, j,(byte & (1 << bitIndex))>0?1:0);
						index++;
					}
				}
			}
			private function zoomMaxClick():void{
				changeZoom(100);
			}
			private function zoomMinClick():void{
				changeZoom(10);
			}
			
			private function zoomInClick():void{
				if(_zoom>=100){
					return;
				}
				changeZoom(_zoom+10);
			}
			private function changeZoom(zoom:int):void{
				cvsMap.x = editWidth/2-(editWidth/2-cvsMap.x)*(zoom)/_zoom;
				cvsMap.y = editHeight/2-(editHeight/2-cvsMap.y)*(zoom)/_zoom;
				cvsMap.scaleX = (zoom)/100;
				cvsMap.scaleY = (zoom)/100;
				_zoom = zoom;
			}
			private function zoomOutClick():void{
				if(_zoom<=10){
					return;
				}
				changeZoom(_zoom-10);
			}
			private var isDraging:Boolean = false;
			private var lastStageX:int;
			private var lastStageY:int;
			private function onMouseDown(event:MouseEvent):void{
				isDraging = true;
				lastStageX = event.stageX;
				lastStageY = event.stageY;
				switch(_editMode){
					case MODE_NORMAL:
						break;
					case MODE_EDIT_ROAD:
						setTerrainGridsInfo(Math.floor(event.localX/Config.terrainWidth),Math.floor(event.localY/Config.terrainHeight),TERRAIN_ROAD,_editTerrainSize);
						break;
					case MODE_EDIT_WALL:
						setTerrainGridsInfo(Math.floor(event.localX/Config.terrainWidth),Math.floor(event.localY/Config.terrainHeight),TERRAIN_WALL,_editTerrainSize);
						break;
				}
			}
			private function onMouseMove(event:MouseEvent):void{
				if(isDraging){
					var stageX:int = event.stageX;
					var stageY:int = event.stageY;
					switch(_editMode){
						case MODE_NORMAL:
							cvsMap.x += stageX - lastStageX;
							cvsMap.y += stageY - lastStageY;
							break;
						case MODE_EDIT_ROAD:
							setTerrainGridsInfo(Math.floor(event.localX/Config.terrainWidth),Math.floor(event.localY/Config.terrainHeight),TERRAIN_ROAD,_editTerrainSize);
							break;
						case MODE_EDIT_WALL:
							setTerrainGridsInfo(Math.floor(event.localX/Config.terrainWidth),Math.floor(event.localY/Config.terrainHeight),TERRAIN_WALL,_editTerrainSize);
							break;
					}
					lastStageX = stageX;
					lastStageY = stageY;
					trace(cvsMap.x,cvsMap.y);
				}
			}
			private function onMouseUp(event:MouseEvent):void{
				isDraging = false;
			}
			private function onClick(event:MouseEvent):void{
				switch(_editMode){
					case MODE_FIND_PATH:
						if(astarNodeList){
							if(findPathStep == 0){
								findPathSX = event.localX;
								findPathSY = event.localY;
							}
							else if(findPathStep == 1){
								findPathEX = event.localX;
								findPathEY = event.localY;
								path = NavMeshAStar.find(astarNodeList,findPathSX,findPathSY,findPathEX,findPathEY);
							}
							drawPath();
							findPathStep = (findPathStep+1)%2;
						}
						break;
					
				}
			}
			private function drawPath():void{
				uiRoute.graphics.clear();
				if(findPathStep == 0){
					uiRoute.graphics.beginFill(0xff0000);
					uiRoute.graphics.drawCircle(findPathSX,findPathSY,20);
					uiRoute.graphics.endFill();
				}
				if(findPathStep == 1){
					uiRoute.graphics.beginFill(0xff0000);
					uiRoute.graphics.drawCircle(findPathSX,findPathSY,20);
					uiRoute.graphics.endFill();
					uiRoute.graphics.beginFill(0xff0000);
					uiRoute.graphics.drawCircle(findPathEX,findPathEY,20);
					uiRoute.graphics.endFill();
					if(path!=null){
						if(path[0]!=null&&path[0].length>0){
							uiRoute.graphics.lineStyle(5,0x00ff00);
							uiRoute.graphics.moveTo(path[0][0][0],path[0][0][1]);
							for(var i:int=1;i<path[0].length;i++){
								uiRoute.graphics.lineTo(path[0][i][0],path[0][i][1]);
							}
						}
						
						if(path[1]!=null&&path[1].length>0){
							uiRoute.graphics.lineStyle(5,0xff0000);
							uiRoute.graphics.moveTo(path[1][0][0],path[1][0][1]);
							for(var i:int=1;i<path[1].length;i++){
								uiRoute.graphics.lineTo(path[1][i][0],path[1][i][1]);
							}
						}
					}
					
					
				}
			}
			
			
			private function onChangeEditMode(mode:int):void{
				switch(mode){
					case MODE_NORMAL:
						this._editMode = mode;
					case MODE_EDIT_ROAD:
						this._editMode = mode;
						break;
					case MODE_EDIT_WALL:
						this._editMode = mode;
						break;
					case MODE_FIND_PATH:
						this._editMode = mode;
						break;
				}
				if(mode != MODE_FIND_PATH){
					findPathStep = 0;
				}
			}
			private function setTerrainGridsInfo(x:int,y:int,terrainType:int,size:int=1):void{
				for(var i:int=0;i<size;i++){
					for(var j:int=0; j<size; j++){
						if(x+i>=0&&x+i<rowNum&&y+j>=0&&y+j<colNum){
							setTerrainInfo(x+i,y+j,terrainType);
						}
					}
				}
				onTerrainChange();
				
			}
			private function clearTerrainInfo():void{
				arcs = [];
				for(var i:int=0; i<rowNum; i++){
					arcs[i] = [];
					for(var j:int=0;j<=colNum; j++){
						arcs[i][j] = TERRAIN_ROAD;
					}
				}
				for(var i:int=0;i<rowNum;i++){
					for(var j:int=0;j<colNum;j++){
						setTerrainInfo(i,j,TERRAIN_ROAD);
					}
				}
			}
			private function setTerrainInfo(x:int,y:int,terrainType:int):void{
				if(terrainType !=0 && terrainType!=1){
					arcs[x][y] = terrainType;
				}
				arcs[x][y] = terrainType;
				if(gridBitmapData){
					if(arcs[x][y] == TERRAIN_ROAD){
						gridBitmapData.fillRect(new Rectangle(Config.terrainWidth*x+1,Config.terrainHeight*y+1,Config.terrainWidth-2,Config.terrainHeight-2),0xffffff);
						
					}
					else{
						gridBitmapData.fillRect(new Rectangle(Config.terrainWidth*x+1,Config.terrainHeight*y+1,Config.terrainWidth-2,Config.terrainHeight-2),0xfed094);
					}
				}
			}
			private function onTerrainChange():void{
				
				
			}
			private function onChangeTerrainSize():void{
				_editTerrainSize = int(tiEditTerrainSize.text);
			}
			private function generalTriangleListClick():void{
				trace(getTimer());
				astarNodeList = CNavMesh.createAstarNode(arcs,colNum,rowNum,Config.terrainWidth,Config.terrainHeight);
				trace(getTimer());
				onAstarNodeListChanged();
			}
			private function onAstarNodeListChanged():void{
				uiTriangleList.graphics.clear();
				if(astarNodeList){
					for(var i:int=0;i<astarNodeList.length; i++){
						var triangle:NavmeshAstarNode = astarNodeList[i];
						uiTriangleList.graphics.lineStyle(2,0x0000ff);
						uiTriangleList.graphics.moveTo(triangle.x1,triangle.y1);
						uiTriangleList.graphics.lineTo(triangle.x2,triangle.y2);
						uiTriangleList.graphics.lineTo(triangle.x3,triangle.y3);
						uiTriangleList.graphics.lineTo(triangle.x1,triangle.y1);
					}
				}
			}
			private function loadTriangleListClick():void{
				var file:File = new File( Data.file.nativePath + Config.triangleName);
				var stream:FileStream = new FileStream();
				var data:ByteArray = new ByteArray;
				stream.open(file, FileMode.READ);
				stream.readBytes(data, 0, stream.bytesAvailable);
				data.uncompress();
				var bytes:ByteArray = new ByteArray();
				data.position = 0;
				var dataList:Vector.<Object> = data.readObject() as Vector.<Object>;
				var len:int = dataList.length;
				var i:int;
				astarNodeList = new Vector.<NavmeshAstarNode>();
				var node:NavmeshAstarNode;
				var nodeData:Object;
				for(i=0; i<len; i++){
					nodeData = dataList[i];
					node = new NavmeshAstarNode(nodeData.x1,nodeData.y1,nodeData.x2,nodeData.y2,nodeData.x3,nodeData.y3);
					node.id = nodeData.id;
					node.linkArr = nodeData.linkArr;
					astarNodeList.push(node);
				}
				onAstarNodeListChanged();
			}
			
			private function saveTriangleListClick():void{
				if(astarNodeList){
					var i:int,len:int;
					len = astarNodeList.length;
					var node:NavmeshAstarNode;
					var triangleList:Array;
					for(i=0; i<len; i++){
						node = astarNodeList[i];
						triangleList.push({x1:node.x1,y1:node.y1,x2:node.x2,y2:node.y2,x3:node.x3,y3:node.y3,linkArr:node.linkArr,id:node.id});
					}
					var file:File = new File( Data.file.nativePath + Config.triangleName);
					var stream:FileStream = new FileStream();
					var data:ByteArray = new ByteArray();
					data.writeObject(triangleList);
					data.compress();
					stream.open(file, FileMode.WRITE);
					stream.writeBytes(data)
					stream.close();
				}
			}
			private function findPathTestClick():void{
				
			}
		]]>
	</mx:Script>
	<mx:Canvas>
		<mx:VBox verticalGap="2">
			<mx:Button label="载入地形信息" width="80" click="loadTerrainInfoClick()" />
			<mx:Button label="普通"  width="80" click="onChangeEditMode(MODE_NORMAL)"/>
			<mx:Button label="标记可过"  width="80" click="onChangeEditMode(MODE_EDIT_ROAD)"/>
			<mx:Button label="标记不可过"  width="80" click="onChangeEditMode(MODE_EDIT_WALL)"/>
			<mx:Button label="全部清除"  width="80"/>
			<mx:Button label="撤销"  width="80" click="undoClick()" enabled="{_recordList.length>0}"/>
			<mx:Button label="保存地形信息"  width="80" click="saveTerrianInfoClick()" />
			<mx:Button label="载入三角网格"  width="80" click="loadTriangleListClick()" />
			<mx:Button label="生成三角网格"  width="80" click="generalTriangleListClick()" />
			<mx:Button label="保存三角网格"  width="80" click="saveTriangleListClick()" />
			<mx:Button label="寻路测试"  width="80" click="onChangeEditMode(MODE_FIND_PATH)" />
		</mx:VBox>
	</mx:Canvas>
	<mx:Canvas x="80" id="cvsTerrainEdit" width="{editWidth}" height="{editHeight}" scrollRect="{new Rectangle(0,0,editWidth,editHeight)}" >
		<mx:Canvas id="cvsMap" mouseChildren="false"
				   mouseMove="onMouseMove(event)" 
				   mouseUp="onMouseUp(event)" 
				   mouseDown="onMouseDown(event)"
				   click="onClick(event)">
			<mx:UIComponent id="uiBitmap"/>
			<mx:UIComponent id="uiTerrain" alpha="0.7"/>
			<mx:UIComponent id="uiTerrainGrid" visible="{_zoom>=30}" />
			<mx:UIComponent id="uiTriangleList" visible="{_editMode == MODE_FIND_PATH || _editMode == MODE_NORMAL}" />
			<mx:UIComponent id="uiRoute" visible="{_editMode == MODE_FIND_PATH || _editMode == MODE_NORMAL}" />
		</mx:Canvas>
	</mx:Canvas>
	<mx:Button x="650" y="{editHeight+5}" width="50" label="max" click="zoomMaxClick()" />
	<mx:Button x="705" y="{editHeight+5}" width="50" label="+" click="zoomInClick()" />
	<mx:Button x="760" y="{editHeight+5}" width="50" label="-" click="zoomOutClick()" />
	<mx:Button x="815" y="{editHeight+5}" width="50" label="min" click="zoomMinClick()" />
	
	<mx:Canvas y="{editHeight+30}" visible="{_editMode==MODE_EDIT_ROAD || _editMode ==MODE_EDIT_WALL}">
		<mx:Label text="大小" x="20"/>
		<mx:TextInput id="tiEditTerrainSize" text="{_editTerrainSize}" width="20" x="50" change="onChangeTerrainSize()" />
	</mx:Canvas>
</mx:Canvas>
